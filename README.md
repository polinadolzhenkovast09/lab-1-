# lab-1
#  Цель работы

### Освоить принципы удаленного вызова процедур (RPC) и их применение в распределенных системах;  изучить основы фреймворка gRPC и языка определения интерфейсов Protocol Buffers (Protobuf); научиться определять сервисы и сообщения с помощью Protobuf; реализовать клиент-серверное приложение на языке Python с использованием gRPC; получить практические навыки в генерации кода, реализации серверной логики и клиентских вызовов для различных типов RPC.

## 10 вариант Управление задачами Сервис TaskManager: метод GetTasksForUser(UserID) для получения потока задач для конкретного пользователя (Server streaming RPC).
## Архитектура
<img width="736" height="724" alt="image" src="https://github.com/user-attachments/assets/f019abdc-834f-4e55-b5a3-f23c7e838857" />



## Компоненты
### Сервер (Server) - server.py Это независимое приложение, которое выполняет основную "бизнес-логику" управления задачами.
### Возможности:
### Предоставляет сервис. Реализует и "выставляет наружу" сервис TaskManager, определенный в контракте (.proto файле).
### Обрабатывает запросы. обрабатывает вызовы от клиентов.
### Выполняет логику. Управляет задачами пользователей - получает данные из базы данных, фильтрует по пользователям и формирует ответы.
### Потоковая передача. Реализует server streaming RPC, постепенно отправляя задачи клиенту по мере их подготовки или получения из источника данных.
### Клиент (Client) - client.py Это приложение, которое потребляет функциональность, предоставляемую сервером управления задачами.
### Возможности:
### Инициирует соединение. Устанавливает соединение с сервером по известному адресу (localhost:50051).
### Вызывает удаленные методы. Обращается к методам сервера (GetTasksForUser) так, как будто это локальные функции.
### Обрабатывает потоковые ответы. Получает и обрабатывает непрерывный поток задач от сервера, отображая их в реальном времени.
### Управляет пользовательскими запросами. Формирует запросы для конкретных пользователей (по UserID) и обрабатывает результаты
## 2. Взаимодействие и Контракт
### Ключевым элементом архитектуры системы управления задачами является сервисный контракт (Service Contract), определенный в файле task_manager.proto.
### Роль контракта
### Этот файл является "единым источником правды" для API системы управления задачами. Он строго описывает:
### Какие сервисы доступны (TaskManager)
### Какие методы можно вызвать у каждого сервиса (GetTasksForUser)
### Какие данные (сообщения) эти методы принимают (GetTasksForUserRequest) и возвращают (поток сообщений Task)
## Технологический стек системы управления задачами
### 1. Язык определения интерфейсов (IDL): Protocol Buffers (Protobuf)
### Назначение: Формальное описание контракта сервиса управления задачами
### Файлы: task_manager.proto - определяет сообщения Task, GetTasksForUserRequest и сервис TaskManager
### Преимущества: Строгая типизация, автоматическая генерация кода, версионность
### 2. Фреймворк RPC: gRPC
### Назначение: Обработка удаленных вызовов для управления задачами
### Особенности: Поддержка server streaming для метода GetTasksForUser
### Преимущества: Высокая производительность, кроссплатформенность


### Управление задачами - это система для создания, организации, отслеживания и выполнения задач в индивидуальной или командной работе.
### Сначала я подготовила окружения.Файл контракта,реализация сервера и клиента. Загрузила папку и установиа питон с помощью команд

<img width="1142" height="362" alt="image" src="https://github.com/user-attachments/assets/fb81f0e3-e1ae-47f5-8e4d-8834fcff064b" />
<img width="1156" height="316" alt="image" src="https://github.com/user-attachments/assets/344c8860-8295-465a-b39c-74b5dd5ffdea" />

### Далее я установила библиотеки gRPC и сгенеририровала код после которого появились две новые папки

<img width="1211" height="209" alt="image" src="https://github.com/user-attachments/assets/5971e389-d314-4372-aa52-47cbcf97000d" />
<img width="295" height="73" alt="image" src="https://github.com/user-attachments/assets/9ebbca4e-7ff7-4a9c-9049-fa03bc01b8e6" />

### Далее открываем два терминала для серверного и клиентского файла. Потом вводим iduser и проверям какие у него есть задачи

<img width="919" height="321" alt="image" src="https://github.com/user-attachments/assets/2db6d7a8-bb7f-4bed-ad52-7cf2e14c010f" />


## Вывод

### Освоила принципы удаленного вызова процедур (RPC) и их применение в распределенных системах; реализовала клиент-серверное приложение на языке Python с использованием gRPC; получила практические навыки в генерации кода, реализации серверной логики и клиентских вызовов 






